import * as core from '@actions/core';
import * as github from '@actions/github';

export interface CIResults {
  test?: {
    status: 'success' | 'failure' | 'skipped';
    coverage?: string;
    error?: string;
  };
  lint?: {
    status: 'success' | 'failure' | 'skipped';
    error?: string;
  };
  benchmark?: {
    status: 'success' | 'failure' | 'skipped';
    config?: {
      args: string;
      count: number;
    };
    error?: string;
  };
  selfValidate?: {
    status: 'success' | 'failure' | 'skipped';
    actionsFound: string[];
    errors: Array<{
      type: string;
      message: string;
    }>;
  };
}

export interface PRCommentOptions {
  workingDirectory?: string;
  commentId?: string;
}

export class UnifiedPRComment {
  private workingDirectory: string;

  constructor(options: PRCommentOptions = {}) {
    this.workingDirectory = options.workingDirectory || '.';
  }

  async updateComment(results: CIResults) {
    // Only run on pull requests
    if (github.context.eventName !== 'pull_request') {
      return;
    }

    const token = core.getInput('github-token') || process.env.GITHUB_TOKEN;
    if (!token) {
      console.log('No GitHub token found, skipping PR comment');
      return;
    }

    const octokit = github.getOctokit(token);
    const comment = this.formatUnifiedComment(results);
    
    // Find existing go-actions comment
    const { data: comments } = await octokit.rest.issues.listComments({
      owner: github.context.repo.owner,
      repo: github.context.repo.repo,
      issue_number: github.context.issue.number,
    });
    
    const botComment = comments.find(c => 
      c.user?.type === 'Bot' && 
      c.body?.includes('# Go Actions Report')
    );
    
    if (botComment) {
      // Update existing comment
      await octokit.rest.issues.updateComment({
        owner: github.context.repo.owner,
        repo: github.context.repo.repo,
        comment_id: botComment.id,
        body: comment
      });
      console.log('Updated unified CI results comment');
    } else {
      // Create new comment
      await octokit.rest.issues.createComment({
        owner: github.context.repo.owner,
        repo: github.context.repo.repo,
        issue_number: github.context.issue.number,
        body: comment
      });
      console.log('Created new unified CI results comment');
    }
  }

  private formatUnifiedComment(results: CIResults): string {
    const hasAnyResults = Object.keys(results).some(key => 
      results[key as keyof CIResults] && results[key as keyof CIResults]!.status !== 'skipped'
    );

    if (!hasAnyResults) {
      return this.formatEmptyComment();
    }

    let comment = '# Go Actions Report\n\n';

    // Status lines
    if (results.selfValidate && results.selfValidate.status !== 'skipped') {
      const icon = results.selfValidate.status === 'success' ? '‚úÖ' : '‚ùå';
      comment += `${icon} **Validated**`;
      if (results.selfValidate.status === 'failure') {
        comment += ` (${results.selfValidate.errors.length} issue${results.selfValidate.errors.length === 1 ? '' : 's'})`;
      }
      comment += '\n';
    }

    if (results.test && results.test.status !== 'skipped') {
      const icon = results.test.status === 'success' ? '‚úÖ' : '‚ùå';
      comment += `${icon} **Tests**`;
      if (results.test.coverage) {
        comment += ` (${results.test.coverage} coverage)`;
      } else if (results.test.status === 'failure') {
        comment += ' (failed)';
      }
      comment += '\n';
    }

    if (results.lint && results.lint.status !== 'skipped') {
      const icon = results.lint.status === 'success' ? '‚úÖ' : '‚ùå';
      comment += `${icon} **Lint**`;
      if (results.lint.status === 'failure') {
        comment += ' (issues found)';
      }
      comment += '\n';
    }

    if (results.benchmark && results.benchmark.status !== 'skipped') {
      const icon = results.benchmark.status === 'success' ? '‚úÖ' : '‚ùå';
      comment += `${icon} **Benchmarks**`;
      if (results.benchmark.status === 'failure') {
        comment += ' (failed)';
      }
      comment += '\n';
    }

    comment += '\n';

    // Details sections
    if (results.selfValidate && results.selfValidate.status !== 'skipped') {
      comment += this.formatValidationDetails(results.selfValidate);
    }

    if (results.test && results.test.status !== 'skipped') {
      comment += this.formatTestDetails(results.test);
    }

    if (results.lint && results.lint.status !== 'skipped') {
      comment += this.formatLintDetails(results.lint);
    }

    if (results.benchmark && results.benchmark.status !== 'skipped') {
      comment += this.formatBenchmarkDetails(results.benchmark);
    }

    // Footer
    comment += '*ü§ñ This comment will update automatically as you push changes.*\n';
    comment += '*Generated by [go-actions](https://github.com/jrschumacher/go-actions)*';

    return comment;
  }

  private getOverallStatus(results: CIResults): 'success' | 'failure' | 'partial' {
    const statuses = Object.values(results)
      .filter(result => result && result.status !== 'skipped')
      .map(result => result!.status);

    if (statuses.length === 0) return 'success';
    if (statuses.every(status => status === 'success')) return 'success';
    if (statuses.some(status => status === 'failure')) return 'failure';
    
    return 'partial';
  }

  private formatSummaryTable(results: CIResults): string {
    const rows: string[] = ['| Job | Status | Details |', '|-----|--------|---------|'];
    
    if (results.test && results.test.status !== 'skipped') {
      const emoji = results.test.status === 'success' ? '‚úÖ' : '‚ùå';
      const details = results.test.coverage ? `Coverage: ${results.test.coverage}` : '';
      rows.push(`| Tests | ${emoji} ${results.test.status} | ${details} |`);
    }

    if (results.lint && results.lint.status !== 'skipped') {
      const emoji = results.lint.status === 'success' ? '‚úÖ' : '‚ùå';
      rows.push(`| Lint | ${emoji} ${results.lint.status} | |`);
    }

    if (results.benchmark && results.benchmark.status !== 'skipped') {
      const emoji = results.benchmark.status === 'success' ? '‚úÖ' : '‚ùå';
      const details = results.benchmark.config ? 
        `${results.benchmark.config.count} runs with \`${results.benchmark.config.args}\`` : '';
      rows.push(`| Benchmarks | ${emoji} ${results.benchmark.status} | ${details} |`);
    }

    if (results.selfValidate && results.selfValidate.status !== 'skipped') {
      const emoji = results.selfValidate.status === 'success' ? '‚úÖ' : '‚ùå';
      const details = results.selfValidate.actionsFound.length > 0 ? 
        `Actions: ${results.selfValidate.actionsFound.join(', ')}` : '';
      rows.push(`| Validation | ${emoji} ${results.selfValidate.status} | ${details} |`);
    }

    return rows.join('\n');
  }

  private formatTestSection(test: NonNullable<CIResults['test']>): string {
    if (test.status === 'success' && test.coverage) {
      const coveragePercent = parseFloat(test.coverage.replace('%', ''));
      const emoji = coveragePercent >= 80 ? 'üéâ' : coveragePercent >= 60 ? '‚ö†Ô∏è' : 'üö®';
      
      return `### üß™ Tests ${coveragePercent >= 80 ? '‚úÖ' : '‚ö†Ô∏è'}

**Coverage: ${test.coverage}**

${emoji} ${coveragePercent >= 80 ? 
  'Excellent test coverage!' :
  coveragePercent >= 60 ?
  'Good coverage, consider adding more tests.' :
  'Low test coverage detected. Please add more tests.'
}

<details>
<summary>Coverage Guidelines</summary>

- üéâ **80%+**: Excellent coverage
- ‚ö†Ô∏è **60-79%**: Good coverage, room for improvement  
- üö® **<60%**: Needs more tests

</details>`;
    } else if (test.status === 'failure') {
      return `### üß™ Tests ‚ùå

**Tests failed!**

${test.error ? `**Error:** ${test.error}` : 'Please check the test logs for details.'}`;
    }

    return `### üß™ Tests ‚úÖ

All tests passed successfully!`;
  }

  private formatLintSection(lint: NonNullable<CIResults['lint']>): string {
    if (lint.status === 'success') {
      return `### üîç Lint ‚úÖ

Code quality checks passed!`;
    } else {
      return `### üîç Lint ‚ùå

**Linting failed!**

${lint.error ? `**Error:** ${lint.error}` : 'Please check the lint logs for details.'}`;
    }
  }

  private formatBenchmarkSection(benchmark: NonNullable<CIResults['benchmark']>): string {
    if (benchmark.status === 'success') {
      return `### ‚ö° Benchmarks ‚úÖ

Benchmarks completed successfully!

${benchmark.config ? `**Configuration:**
- Args: \`${benchmark.config.args}\`
- Runs: ${benchmark.config.count}` : ''}

üèÉ‚Äç‚ôÇÔ∏è All benchmark tests passed. Performance metrics have been captured.`;
    } else {
      return `### ‚ö° Benchmarks ‚ùå

**Benchmarks failed!**

${benchmark.error ? `**Error:** ${benchmark.error}` : ''}

${benchmark.config ? `**Configuration:**
- Args: \`${benchmark.config.args}\`
- Runs: ${benchmark.config.count}` : ''}

Please check your benchmark functions and try again.`;
    }
  }

  private formatSelfValidateSection(selfValidate: NonNullable<CIResults['selfValidate']>): string {
    if (selfValidate.status === 'success') {
      return `### üîç Configuration Validation ‚úÖ

All go-actions configuration is valid!

${selfValidate.actionsFound.length > 0 ? 
  `**Actions detected:** ${selfValidate.actionsFound.join(', ')}` : 
  '**No go-actions detected in workflows**'
}`;
    } else {
      return `### üîç Configuration Validation ‚ùå

**Validation failed!**

${selfValidate.errors.map(error => `- ${error.message}`).join('\n')}

${selfValidate.actionsFound.length > 0 ? 
  `**Actions detected:** ${selfValidate.actionsFound.join(', ')}` : ''
}`;
    }
  }

  private formatValidationDetails(selfValidate: NonNullable<CIResults['selfValidate']>): string {
    if (selfValidate.status === 'success') {
      return `<details><summary>Validation Details</summary>\n\n**Actions configured:** ${selfValidate.actionsFound.join(', ')}\n\n**Checks passed:**\n- Configuration files present\n- Version compatibility verified\n- Workflow syntax valid\n\n</details>\n\n`;
    } else {
      let details = '<details open><summary>Validation Issues</summary>\n\n';
      for (let i = 0; i < selfValidate.errors.length; i++) {
        details += `${i + 1}. ${selfValidate.errors[i].message}\n`;
      }
      details += '\n</details>\n\n';
      return details;
    }
  }

  private formatTestDetails(test: NonNullable<CIResults['test']>): string {
    if (test.status === 'success') {
      if (test.coverage) {
        const coveragePercent = parseFloat(test.coverage.replace('%', ''));
        const emoji = coveragePercent >= 80 ? 'üéâ' : coveragePercent >= 60 ? '‚ö†Ô∏è' : 'üö®';
        
        return `<details><summary>Test Details</summary>\n\n**Coverage: ${test.coverage}**\n\n${emoji} ${coveragePercent >= 80 ? 
          'Excellent test coverage!' :
          coveragePercent >= 60 ?
          'Good coverage, consider adding more tests.' :
          'Low test coverage detected. Please add more tests.'
        }\n\n</details>\n\n`;
      } else {
        return `<details><summary>Test Details</summary>\n\nAll tests passed successfully!\n\n</details>\n\n`;
      }
    } else {
      return `<details open><summary>Test Issues</summary>\n\n**Tests failed!**\n\n${test.error ? `**Error:** ${test.error}` : 'Please check the test logs for details.'}\n\n</details>\n\n`;
    }
  }

  private formatLintDetails(lint: NonNullable<CIResults['lint']>): string {
    if (lint.status === 'success') {
      return `<details><summary>Lint Details</summary>\n\nCode quality checks passed!\n\n</details>\n\n`;
    } else {
      return `<details open><summary>Lint Issues</summary>\n\n**Linting failed!**\n\n${lint.error ? `**Error:** ${lint.error}` : 'Please check the lint logs for details.'}\n\n</details>\n\n`;
    }
  }

  private formatBenchmarkDetails(benchmark: NonNullable<CIResults['benchmark']>): string {
    if (benchmark.status === 'success') {
      return `<details><summary>Benchmark Details</summary>\n\nBenchmarks completed successfully!\n\n${benchmark.config ? `**Configuration:**\n- Args: \`${benchmark.config.args}\`\n- Runs: ${benchmark.config.count}` : ''}\n\n</details>\n\n`;
    } else {
      return `<details open><summary>Benchmark Issues</summary>\n\n**Benchmarks failed!**\n\n${benchmark.error ? `**Error:** ${benchmark.error}` : ''}\n\n${benchmark.config ? `**Configuration:**\n- Args: \`${benchmark.config.args}\`\n- Runs: ${benchmark.config.count}` : ''}\n\n</details>\n\n`;
    }
  }

  private formatEmptyComment(): string {
    return `# Go Actions Report

‚è≥ **Pending**

<details><summary>Details</summary>

No CI jobs have run yet. Results will appear here as jobs complete.

</details>

*ü§ñ This comment will update automatically as you push changes.*
*Generated by [go-actions](https://github.com/jrschumacher/go-actions)*`;
  }

  // Static method to store results in GitHub Actions artifacts/environment
  static async storeResults(jobType: keyof CIResults, jobResults: any) {
    const key = `GO_ACTIONS_${jobType.toUpperCase()}_RESULTS`;
    const serialized = JSON.stringify(jobResults);
    
    // Store in environment for other jobs to read
    core.exportVariable(key, serialized);
    core.setOutput(`${jobType}_results`, serialized);
    
    console.log(`Stored ${jobType} results for unified comment`);
  }

  // Static method to load all stored results
  static loadStoredResults(): CIResults {
    const results: CIResults = {};
    const jobTypes: (keyof CIResults)[] = ['test', 'lint', 'benchmark', 'selfValidate'];
    
    for (const jobType of jobTypes) {
      const key = `GO_ACTIONS_${jobType.toUpperCase()}_RESULTS`;
      const stored = process.env[key];
      
      if (stored) {
        try {
          results[jobType] = JSON.parse(stored);
        } catch (error) {
          console.log(`Failed to parse stored results for ${jobType}: ${error}`);
        }
      }
    }
    
    return results;
  }
}

// Export functions for direct use
export async function updateUnifiedComment(results: CIResults, options: PRCommentOptions = {}) {
  const commenter = new UnifiedPRComment(options);
  await commenter.updateComment(results);
}

export async function storeJobResults(jobType: keyof CIResults, jobResults: any) {
  await UnifiedPRComment.storeResults(jobType, jobResults);
}

export function loadAllResults(): CIResults {
  return UnifiedPRComment.loadStoredResults();
}